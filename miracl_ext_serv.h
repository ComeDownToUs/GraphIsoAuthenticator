/*
 * Functions designed for the purpose of encoding a key into a graph
 * 
 */

void mir_init(miracl *mir);
void mir_bin_to_array(char *bytes, char *array);
void mir_array_to_bin(char *bytes, char *array);
void mir_embed(char *perm, char *arr, int loc, char *roundG, char *origin);
void mir_readembed(char *graphy, char *theNum, int loc);

/*** miracl variables ***/
//big priA, pubA;//, pubB; ///??memalloc??
big prime, key;
miracl *mip;///?needed?
//char byteA[ROUNDS], arrA[THEMAX];///stores binary of graph enlarged REMOVE LATER
/*
char sendBits[THEMAX/8], *recBits;///needed?
char sendArr[THEMAX];///stores binary of graph enlarged REMOVE LATER
*/
char *primetext=
//From RFC 3256
/*4096 bit*/ //"1044388881413152506679602719846529545831269060992135009022588756444338172022322690710444046669809783930111585737890362691860127079270495454517218673016928427459146001866885779762982229321192368303346235204368051010309155674155697460347176946394076535157284994895284821633700921811716738972451834979455897010306333468590751358365138782250372269117968985194322444535687415522007151638638141456178420621277822674995027990278673458629544391736919766299005511505446177668154446234882665961680796576903199116089347634947187778906528008004756692571666922964122566174582776707332452371001272163776841229318324903125740713574141005124561965913888899753461735347970011693256316751660678950830027510255804846105583465055446615090444309583050775808509297040039680057435342253926566240898195863631588888936364129920059308455669454034010391478238784189888594672336242763795138176353222845524644040094258962433613354036104643881925238489224010194193088911666165584229424668165441688927790460608264864204237717002054744337988941974661214699689706521543006262604535890998125752275942608772174376107314217749233048217904944409836238235772306749874396760463376480215133461333478395682746608242585133953883882226786118030184028136755970045385534758453247";
/*3072 bit*/ //"5809605995369958062791915965639201402176612226902900533702900882779736177890990861472094774477339581147373410185646378328043729800750470098210924487866935059164371588168047540943981644516632755067501626434556398193186628990071248660819361205119793693985433297036118232914410171876807536457391277857011849897410207519105333355801121109356897459426271845471397952675959440793493071628394122780510124618488232602464649876850458861245784240929258426287699705312584509625419513463605155428017165714465363094021609290561084025893662561222573202082865797821865270991145082200656978177192827024538990239969175546190770645685893438011714430426409338676314743571154537142031573004276428701433036381801705308659830751190352946025482059931306571004727362479688415574702596946457770284148435989129632853918392117997472632693078113129886487399347796982772784615865232621289656944284216824611318709764535152507354116344703769998514148343807";
/*2048 bit*/ //"32317006071311007300338913926423828248817941241140239112842009751400741706634354222619689417363569347117901737909704191754605873209195028853758986185622153212175412514901774520270235796078236248884246189477587641105928646099411723245426622522193230540919037680524235519125679715870117001058055877651038861847280257976054903569732561526167081339361799541336476559160368317896729073178384589680639671900977202194168647225871031411336429319536193471636533209717077448227988588565369208645296636077250268955505928362751121174096972998068410554359584866583291642136218231078990999448652468262416972035911852507045361090559";
/*1526 bit*/ "2410312426921032588552076022197566074856950548502459942654116941958108831682612228890093858261341614673227141477904012196503648957050582631942730706805009223062734745341073406696246014589361659774041027169249453200378729434170325843778659198143763193776859869524088940195577346119843545301547043747207749969763750084308926339295559968882457872412993810129130294592999947926365264059284647209730384947211681434464714438488520940127459844288859336526896320919633919";
//From RFC 2409
/*1024 bit*/ //"179769313486231590770839156793787453197860296048756011706444423684197180216158519368947833795864925541502180565485980503646440548199239100050792877003355816639229553136239076508735759914822574862575007425302077447712589550957937778424442426617334727629299387668709205606050270810842907692932019128194467627007";
/* 768 bit*/ //"1552518092300708935130918131258481755631334049434514313202351194902966239949102107258669453876591642442910007680288864229150803718918046342632727613031282983744380820890196288509170691316593175367469551763119843371637221007210577919";


///PADRAIG, YOU CHANGED THE GENERATOR AND
///THE PRIVATE KEY SIZE WITHOUT EVEN TESTING
///THEM!
///THAT'S PROBABLY WHAT'S WRONG!
void mir_init(miracl *mir)
{
	time_t seed;
	big n;
    
    
    mirsys(-488,0);
    /*
    #ifndef MR_NOFULLWIDTH   
		mir=mirsys(-ROUNDS,0);
	#else
		mir=mirsys(-ROUNDS,MAXBASE);
	#endif
	* */
	
	/*THEKEYSTUFF*/
	prime=mirvar(0);
	cinstr(prime, primetext);
	printf("The big numba: ");
	cotnum(prime, stdout);
	/**/
	
	srand(time(NULL));
	time(&seed);
    irand((unsigned long)seed);   /* change parameter for different values */
 
	
}

int init_thre(big a, char *y)
{
	big pa;
	   
	
	pa=mirvar(0); 
	key=mirvar(0);
	   
    bigbits(256, a);
	puts("\nInput Number");
	cotnum(a, stdout);
	
    //big_to_bytes(THEMAX/8, x, numba, TRUE);
	
	/*THEKEYSTUFF*/
	printf("Your public: ");  
    powltr(2, a, prime, pa);
    cotnum(pa, stdout);
    
    
	puts("hey?");
     
    big_to_bytes(ROUNDS, pa, y, TRUE);
    /**/
}

void mir_bin_to_array(char *bites, char *arr){
	int byteindex=0;
	int bitindex=0;
	int i;
	/*for(j=0; j<20; j++)
		//printf("Byte #%2d: %d \t", j, bites[j]);
		*/
			
	for(i=0; i<ROUNDS*8;i++)
	{
		//printf("%d, ", i);
		arr[i]=(bites[byteindex]>>bitindex)&1;

	/*
		printf("%3d %2d|%d|%d, ", i, byteindex, bitindex, arr[i]);
		if(i%5==0)
			printf("\n");
	*/				
		if(++bitindex>7)
		{
			bitindex=0;
			//printf("Byte #%d: %d", byteindex, bites[byteindex]);
			byteindex++;
		}
	}
}

void mir_array_to_bin(char *bites, char *arr)
{	
	int h, i;
	int byteindex=0;
	int bitindex=0;
	
	//resetting values of bites
	//for(h=0;h<(THEMAX/8);h++){
	for(h=0;h<(ROUNDS);h++){
		bites[h]=0;
	}	
	for(h=0;h<(THEMAX);h++){
		if(arr[h]==1){
			bites[byteindex] |= (1<<bitindex);
		}
		if(++bitindex>7){
			bitindex=0;
			byteindex++;
		}
	}
}

void mir_embed(char *perm, char *arr, int loc, char *userG, char *origG)
{
	char newperm[VERTICES+1], used[8], graffer[COMPRESS_SIZE], graph[VERTICES*VERTICES];
	int i=0, j=8;
	int k, l;
	char m=1;
	
	memcpy(newperm, perm, (sizeof(char)*VERTICES)+1);
	
	permGraph(perm, graffer, userG, origG);
	decompress_graph(graffer, graph);
	
	/*
	 * current system requires graph to have a guarantee of at least eight required 
	 * bits to be available further up the graph (i.e. working here from position 1-7 and 16 onward
	 * and looking for 8 bits, there needs to be a guarantee of eight unset and eight set 
	 * bits before the ninth entry or after the sixteenth
	 */
	for(j=8; j<16; j++)
	{
		if(arr[(loc*8)+i]==graph[j])
		{
			used[i]=j;
		}
		else
		{
			for(k=16; k<VERTICES; k++)
			{
				if(arr[(loc*8)+i]==graph[k])
				{
					m=1;
					for(l=0; l<i; l++)
					{
						if(used[l]==k)
						{
							m=0;
							break;
						}
					}
					if (m==1)
					{
						newperm[j] = perm[k];
						newperm[k] = perm[j];
						used[i]=k;
						break;
					}
				}
				//if(k==7) k=15; //not sure why doing 1-7 was causing issues
			}	
		}
		i++;
	}
	memcpy(perm, newperm, sizeof(char)*VERTICES+2);
	
}

void mir_readembed(char *graphy, char *theNum, int loc)
{
	int j=0;
	char bigGraph[VERTICES*VERTICES];
	decompress_graph(graphy, bigGraph);
	for(j=0; j<8; j++){
		theNum[(loc*8)+j]=bigGraph[j+8];}
}

void print_arr(char *arr)
{
	int i;
	for(i=0; i<THEMAX; i++)
	{
		if(i%25==0)
			printf("\n");
		printf("%d|", arr[i]);
		
	}
		printf("\n");
}
